#!/bin/bash

# cake-autortt - Automatically adjust CAKE qdisc RTT parameter
# based on measured RTT to active network connections
# 
# Ubuntu/Debian version - adapted for systemd and standard Linux distributions
#
# This script monitors active connections using /proc/net/nf_conntrack,
# probes non-LAN hosts using ping (3 pings per host sequentially), and adjusts
# of CAKE qdisc on both ingress and egress interfaces.

VERSION="1.2.0-ubuntu"

# Configuration file
CONFIG_FILE="/etc/default/cake-autortt"

# Default configuration
RTT_UPDATE_INTERVAL=5
MIN_HOSTS=3
MAX_HOSTS=20
RTT_MARGIN_PERCENT=10
DEFAULT_RTT_MS=100
DL_INTERFACE=""
UL_INTERFACE=""
DEBUG=0

# Global variables
CURRENT_RTT_MS=0
HOSTS_COUNT=0
PIDFILE="/var/run/cake-autortt.pid"
TEMP_HOSTS="/tmp/cake-autortt-hosts.$$"

# Load configuration from /etc/default/cake-autortt
load_config() {
	if [ -f "$CONFIG_FILE" ]; then
		# Source the configuration file
		# shellcheck source=/etc/default/cake-autortt
		. "$CONFIG_FILE"
		
		# Validate interface settings
		if [ "$DL_INTERFACE" = "auto" ] || [ "$UL_INTERFACE" = "auto" ]; then
			detect_interfaces
		fi
	else
		log_msg "WARN" "Configuration file $CONFIG_FILE not found, using defaults"
		detect_interfaces
	fi
}

detect_interfaces() {
	local cake_interfaces
	cake_interfaces=$(tc qdisc show 2>/dev/null | grep "qdisc cake" | awk '{print $5}' | head -2)
	
	if [ -z "$cake_interfaces" ]; then
		log_msg "ERROR" "No CAKE interfaces found. Please configure CAKE qdisc first."
		exit 1
	fi
	
	if [ "$DL_INTERFACE" = "auto" ] || [ -z "$DL_INTERFACE" ]; then
		# Try to detect download interface (typically ifb-* or similar)
		DL_INTERFACE=$(echo "$cake_interfaces" | grep "ifb" | head -1)
		[ -z "$DL_INTERFACE" ] && DL_INTERFACE=$(echo "$cake_interfaces" | head -1)
	fi
	
	if [ "$UL_INTERFACE" = "auto" ] || [ -z "$UL_INTERFACE" ]; then
		# Try to detect upload interface (typically physical interface)
		UL_INTERFACE=$(echo "$cake_interfaces" | grep -v "ifb" | head -1)
		[ -z "$UL_INTERFACE" ] && UL_INTERFACE=$(echo "$cake_interfaces" | tail -1)
	fi
	
	log_msg "DEBUG" "Auto-detected interfaces: DL=$DL_INTERFACE UL=$UL_INTERFACE"
}

log_msg() {
	local level="$1"
	local message="$2"
	local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
	
	# Only log DEBUG messages to journal/syslog if debug is enabled
	if [ "$level" = "DEBUG" ] && [ "$DEBUG" != "1" ]; then
		# Skip DEBUG messages when debug is disabled
		return
	fi
	
	# Log to systemd journal (appears in journalctl)
	if command -v systemd-cat >/dev/null 2>&1; then
		echo "$message" | systemd-cat -t cake-autortt -p info
	else
		# Fallback to syslog
		logger -t "cake-autortt" "$level: $message"
	fi
	
	# Print to stdout if debug enabled or level is INFO/ERROR
	if [ "$DEBUG" = "1" ] || [ "$level" = "INFO" ] || [ "$level" = "ERROR" ]; then
		echo "[$timestamp] cake-autortt $level: $message"
	fi
}

show_help() {
	cat << EOF
cake-autortt v$VERSION - Automatically adjust CAKE qdisc RTT parameter (Ubuntu/Debian)

Usage: cake-autortt [OPTIONS]

OPTIONS:
  --config FILE                   Use alternative configuration file (default: $CONFIG_FILE)
  --rtt-update-interval SECONDS   Interval between qdisc RTT updates (default: $RTT_UPDATE_INTERVAL)
  --min-hosts NUMBER              Minimum hosts needed for RTT calculation (default: $MIN_HOSTS)
  --max-hosts NUMBER              Maximum hosts to probe simultaneously (default: $MAX_HOSTS)
  --rtt-margin-percent PERCENT    Percentage margin added to measured RTT (default: $RTT_MARGIN_PERCENT)
  --default-rtt-ms MILLISECONDS   Default RTT when no hosts available (default: $DEFAULT_RTT_MS)
  --dl-interface INTERFACE        Download interface (auto-detected if not specified)
  --ul-interface INTERFACE        Upload interface (auto-detected if not specified)
  --debug                         Enable debug logging
  --help                          Show this help message
  --version                       Show version information

EXAMPLES:
  cake-autortt --debug
  cake-autortt --rtt-update-interval 15 --dl-interface ifb0 --ul-interface eth0

CONFIGURATION:
  Edit /etc/default/cake-autortt to set persistent configuration.
  Command line options override configuration file settings.

The script automatically detects active network connections from /proc/net/nf_conntrack,
filters out LAN addresses, and uses ping to measure RTT to external hosts.
Each host is pinged 3 times sequentially to calculate individual averages,
then a final average RTT is calculated across all responsive hosts.
The measured RTT is then used to adjust the CAKE qdisc RTT parameter on both
ingress and egress interfaces for optimal performance.

This sequential ping approach prevents network overload that can occur
with bulk ping utilities when probing many hosts simultaneously.
EOF
}

show_version() {
	echo "cake-autortt version $VERSION (Ubuntu/Debian port)"
}

parse_args() {
	while [ $# -gt 0 ]; do
		case "$1" in
			--config)
				CONFIG_FILE="$2"
				shift 2
				;;
			--rtt-update-interval)
				RTT_UPDATE_INTERVAL="$2"
				shift 2
				;;
			--min-hosts)
				MIN_HOSTS="$2"
				shift 2
				;;
			--max-hosts)
				MAX_HOSTS="$2"
				shift 2
				;;
			--rtt-margin-percent)
				RTT_MARGIN_PERCENT="$2"
				shift 2
				;;
			--default-rtt-ms)
				DEFAULT_RTT_MS="$2"
				shift 2
				;;
			--dl-interface)
				DL_INTERFACE="$2"
				shift 2
				;;
			--ul-interface)
				UL_INTERFACE="$2"
				shift 2
				;;
			--debug)
				DEBUG=1
				shift
				;;
			--help)
				show_help
				exit 0
				;;
			--version)
				show_version
				exit 0
				;;
			*)
				echo "Unknown option: $1" >&2
				echo "Use --help for usage information" >&2
				exit 1
				;;
		esac
	done
}

is_lan_address() {
	local ip="$1"
	
	# Check for private IP ranges
	case "$ip" in
		10.*|172.1[6-9].*|172.2[0-9].*|172.3[01].*|192.168.*|169.254.*|127.*|224.*|240.*)
			return 0
			;;
		::1|fe80:*|fc*|fd*)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

extract_hosts_from_conntrack() {
	# Parse /proc/net/nf_conntrack to extract non-LAN destination addresses
	local hosts_file="$1"
	
	log_msg "DEBUG" "Extracting hosts from conntrack"
	
	# Clear the hosts file
	> "$hosts_file"
	
	# Parse conntrack entries
	# Format: ipv4 2 tcp 6 299 ESTABLISHED src=192.168.1.100 dst=93.184.216.34 ...
	if [ -f "/proc/net/nf_conntrack" ]; then
		awk '
		/^ipv4.*ESTABLISHED/ {
			# Extract dst= field
			for (i = 1; i <= NF; i++) {
				if ($i ~ /^dst=/) {
					dst = substr($i, 5)  # Remove "dst="
					print dst
				}
			}
		}
		' /proc/net/nf_conntrack | while read -r host; do
			if ! is_lan_address "$host"; then
				echo "$host" >> "$hosts_file"
			fi
		done
		
		# Remove duplicates and limit to max hosts
		sort "$hosts_file" | uniq | head -n "$MAX_HOSTS" > "${hosts_file}.tmp"
		mv "${hosts_file}.tmp" "$hosts_file"
		
		HOSTS_COUNT=$(wc -l < "$hosts_file")
		log_msg "DEBUG" "Found $HOSTS_COUNT non-LAN hosts"
	else
		log_msg "ERROR" "/proc/net/nf_conntrack not available"
		HOSTS_COUNT=0
	fi
}

measure_rtt_ping() {
	local hosts_file="$1"
	local host_count
	local alive_count=0
	local total_rtt=0
	local worst_rtt=0
	local host_rtt_sum
	local host_rtt_count
	local host_avg_rtt
	local ping_output
	local rtt_value
	
	if [ ! -s "$hosts_file" ]; then
		log_msg "DEBUG" "No hosts to probe"
		return 1
	fi
	
	host_count=$(wc -l < "$hosts_file")
	log_msg "DEBUG" "Measuring RTT using ping for $host_count hosts (3 pings each)"
	
	# Ping each host individually
	while read -r host; do
		[ -z "$host" ] && continue
		
		host_rtt_sum=0
		host_rtt_count=0
		
		# Ping the host 3 times
		for i in 1 2 3; do
			ping_output=$(ping -c 1 -W 3 "$host" 2>/dev/null)
			
			# Extract RTT from ping output (time=XX.XXX ms)
			rtt_value=$(echo "$ping_output" | grep "time=" | sed 's/.*time=\([0-9]*\.[0-9]*\).*/\1/')
			
			if [ -n "$rtt_value" ] && [ "$(echo "$rtt_value" | grep -E '^[0-9]+(\.[0-9]+)?$')" ]; then
				# Add to host sum (using awk for floating point arithmetic)
				host_rtt_sum=$(echo "$host_rtt_sum $rtt_value" | awk '{print $1 + $2}')
				host_rtt_count=$((host_rtt_count + 1))
			fi
		done
		
		# Calculate average RTT for this host if we got any responses
		if [ "$host_rtt_count" -gt 0 ]; then
			host_avg_rtt=$(echo "$host_rtt_sum $host_rtt_count" | awk '{printf "%.3f", $1 / $2}')
			total_rtt=$(echo "$total_rtt $host_avg_rtt" | awk '{print $1 + $2}')
			
			# Track worst (highest) RTT
			if [ "$(echo "$host_avg_rtt > $worst_rtt" | awk '{print ($1 > $2)}')" = "1" ]; then
				worst_rtt="$host_avg_rtt"
			fi
			
			alive_count=$((alive_count + 1))
			log_msg "DEBUG" "Host $host: avg RTT ${host_avg_rtt}ms from $host_rtt_count pings"
		fi
		# log_msg "DEBUG" "Host $host: no response"
	done < "$hosts_file"
	
	log_msg "DEBUG" "ping summary: $alive_count/$host_count hosts alive"
	
	# Check if we have enough responding hosts
	if [ "$alive_count" -ge "$MIN_HOSTS" ] && [ "$(echo "$total_rtt > 0" | awk '{print ($1 > 0)}')" = "1" ]; then
		# Calculate final average RTT across all hosts
		local avg_rtt
		avg_rtt=$(echo "$total_rtt $alive_count" | awk '{printf "%.3f", $1 / $2}')
		
		# Use worst RTT if it's higher than average, otherwise use average
		if [ "$(echo "$worst_rtt > $avg_rtt" | awk '{print ($1 > $2)}')" = "1" ]; then
			CURRENT_RTT_MS="$worst_rtt"
			log_msg "DEBUG" "Using worst RTT: ${CURRENT_RTT_MS}ms (avg: ${avg_rtt}ms, worst: ${worst_rtt}ms)"
		else
			CURRENT_RTT_MS="$avg_rtt"
			log_msg "DEBUG" "Using average RTT: ${CURRENT_RTT_MS}ms (avg: ${avg_rtt}ms, worst: ${worst_rtt}ms)"
		fi
		
		return 0
	fi
	
	log_msg "DEBUG" "Not enough responding hosts ($alive_count < $MIN_HOSTS)"
	return 1
}

update_cake_rtt() {
	local target_rtt_ms="$1"
	
	# Add margin to measured RTT using awk for arithmetic with 2 decimal precision
	local adjusted_rtt
	adjusted_rtt=$(echo "$target_rtt_ms $RTT_MARGIN_PERCENT" | awk '{printf "%.2f", $1 * (1 + $2 / 100)}')
	
	# Convert to microseconds for tc command with proper precision
	local rtt_us
	rtt_us=$(echo "$adjusted_rtt" | awk '{printf "%.0f", $1 * 1000}')
	
	local updated_count=0
	
	log_msg "INFO" "Adjusting CAKE RTT to ${adjusted_rtt}ms (${rtt_us}us)"
	
	# Update download interface
	if [ -n "$DL_INTERFACE" ]; then
		if tc qdisc show dev "$DL_INTERFACE" | grep -q "qdisc cake"; then
			tc qdisc change dev "$DL_INTERFACE" root cake rtt "${rtt_us}us"
			if [ $? -eq 0 ]; then
				log_msg "DEBUG" "Updated RTT on download interface $DL_INTERFACE"
				updated_count=$((updated_count + 1))
			else
				log_msg "ERROR" "Failed to update RTT on download interface $DL_INTERFACE"
			fi
		else
			log_msg "WARN" "No CAKE qdisc found on download interface $DL_INTERFACE"
		fi
	fi
	
	# Update upload interface (if different from download)
	if [ -n "$UL_INTERFACE" ] && [ "$UL_INTERFACE" != "$DL_INTERFACE" ]; then
		if tc qdisc show dev "$UL_INTERFACE" | grep -q "qdisc cake"; then
			tc qdisc change dev "$UL_INTERFACE" root cake rtt "${rtt_us}us"
			if [ $? -eq 0 ]; then
				log_msg "DEBUG" "Updated RTT on upload interface $UL_INTERFACE"
				updated_count=$((updated_count + 1))
			else
				log_msg "ERROR" "Failed to update RTT on upload interface $UL_INTERFACE"
			fi
		else
			log_msg "WARN" "No CAKE qdisc found on upload interface $UL_INTERFACE"
		fi
	fi
	
	if [ $updated_count -eq 0 ]; then
		log_msg "ERROR" "Failed to update any CAKE interfaces"
		return 1
	fi
	
	return 0
}

cleanup() {
	log_msg "INFO" "Shutting down cake-autortt"
	rm -f "$TEMP_HOSTS" "${TEMP_HOSTS}.tmp"
	rm -f "$PIDFILE"
	exit 0
}

check_dependencies() {
	local missing_deps=""
	
	if ! command -v ping >/dev/null 2>&1; then
		missing_deps="$missing_deps ping"
	fi
	
	if ! command -v tc >/dev/null 2>&1; then
		missing_deps="$missing_deps iproute2"
	fi
	
	if [ -n "$missing_deps" ]; then
		log_msg "ERROR" "Missing dependencies:$missing_deps"
		log_msg "ERROR" "Install with: sudo apt install$missing_deps"
		exit 1
	fi
	
	# Check for CAKE support
	if ! tc qdisc help 2>/dev/null | grep -q cake; then
		log_msg "ERROR" "CAKE qdisc support not available in tc"
		log_msg "ERROR" "Ensure your kernel and iproute2 package support CAKE"
		exit 1
	fi
	
	# Check for conntrack
	if [ ! -f "/proc/net/nf_conntrack" ]; then
		log_msg "ERROR" "/proc/net/nf_conntrack not available"
		log_msg "ERROR" "Ensure netfilter connection tracking is enabled"
		exit 1
	fi
}

# Main execution
main() {
	# Parse command line arguments first
	parse_args "$@"
	
	# Load configuration
	load_config
	
	# Check dependencies
	check_dependencies
	
	# Set up signal handlers
	trap cleanup TERM INT
	
	# Create PID file
	echo $$ > "$PIDFILE"
	
	log_msg "INFO" "Starting cake-autortt v$VERSION"
	log_msg "INFO" "Interfaces: DL=$DL_INTERFACE UL=$UL_INTERFACE"
	log_msg "INFO" "Update interval: ${RTT_UPDATE_INTERVAL}s, Min hosts: $MIN_HOSTS, Max hosts: $MAX_HOSTS"
	
	# Main loop
	while true; do
		# Extract hosts from conntrack
		extract_hosts_from_conntrack "$TEMP_HOSTS"
		
		if [ "$HOSTS_COUNT" -ge "$MIN_HOSTS" ]; then
			# Measure RTT using ping
			if measure_rtt_ping "$TEMP_HOSTS"; then
				# Update CAKE RTT parameter
				update_cake_rtt "$CURRENT_RTT_MS"
			else
				log_msg "WARN" "RTT measurement failed, using default RTT: ${DEFAULT_RTT_MS}ms"
				update_cake_rtt "$DEFAULT_RTT_MS"
			fi
		else
			log_msg "WARN" "Insufficient hosts ($HOSTS_COUNT < $MIN_HOSTS), using default RTT: ${DEFAULT_RTT_MS}ms"
			update_cake_rtt "$DEFAULT_RTT_MS"
		fi
		
		# Wait for next update
		sleep "$RTT_UPDATE_INTERVAL"
	done
}

# Run main function if script is executed directly
if [ "${BASH_SOURCE[0]}" = "${0}" ]; then
	main "$@"
fi